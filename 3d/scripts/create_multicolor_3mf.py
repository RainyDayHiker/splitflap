#!/usr/bin/env python3

#   Copyright 2025 Scott Bezek and the splitflap contributors
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.


"""
Create a 3MF file for multi-material printing of splitflap flaps.

This script takes the STL files generated by generate_3d_print_flaps.py and combines them
into a single 3MF file suitable for multi-material printing in PrusaSlicer. Each component
(flap body, front letter, back letter) is assigned to a different extruder.

The script now uses PrusaSlicer's native multi-material approach:
- Each flap is created as a single 3MF object with combined geometry
- Material assignments are handled via triangle material IDs (pid attribute)
- A slic3r_pe_model.config file is included for PrusaSlicer compatibility
- Objects are properly positioned on the print bed with correct spacing
- Odd-numbered flaps are automatically flipped front-to-back (180Â° around Y-axis)

Usage:
    python create_multicolor_3mf.py --input build/flap_3dp --output flaps_multicolor.3mf --count 3

The script expects the input directory to contain subdirectories like:
    flap_00/, flap_01/, flap_02/, etc.
Each containing:
    00_flap.stl, 00_letter_front.stl, 00_letter_back.stl
    OR
    00_flap.stl, 00_letters.stl

Note: Odd-numbered flaps (flap_01, flap_03, etc.) will be automatically flipped front-to-back
to create an alternating pattern on the print bed.
"""

import argparse
import logging
import os
import sys
import xml.etree.ElementTree as ET
import zipfile
from pathlib import Path

try:
    import trimesh
    import numpy as np
except ImportError:
    print(
        "Error: trimesh and numpy libraries are required. Install them with: pip install trimesh numpy"
    )
    sys.exit(1)

# Add the repo root to the path for utility imports
script_dir = os.path.dirname(os.path.abspath(__file__))
source_parts_dir = os.path.dirname(script_dir)
repo_root = os.path.dirname(source_parts_dir)
sys.path.append(repo_root)

from util import file_util


def create_3mf_model_xml(flaps_data):
    """
    Create the 3MF model XML structure with combined meshes for each flap.

    Args:
        flaps_data: List of dicts with flap information including combined mesh and positions

    Returns:
        XML string for the model file
    """
    # Create root model element
    model = ET.Element(
        "model",
        unit="millimeter",
        xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02",
    )

    # Add metadata
    metadata = ET.SubElement(model, "metadata", name="Application")
    metadata.text = "splitflap-multicolor-generator"

    # Resources section
    resources = ET.SubElement(model, "resources")

    # Add materials
    # Material 1: Flap body (black)
    mat1 = ET.SubElement(resources, "basematerials", id="1")
    base1 = ET.SubElement(mat1, "base", name="Flap Body", displaycolor="#2F2F2F")

    # Material 2: Front letters (white)
    mat2 = ET.SubElement(resources, "basematerials", id="2")
    base2 = ET.SubElement(mat2, "base", name="Front Letters", displaycolor="#FFFFFF")

    # Material 3: Back letters (white)
    mat3 = ET.SubElement(resources, "basematerials", id="3")
    base3 = ET.SubElement(mat3, "base", name="Back Letters", displaycolor="#FFFFFF")

    # Create one object per flap with combined geometry
    object_id = 4  # Start object IDs from 4

    for flap_data in flaps_data:
        obj = ET.SubElement(resources, "object", id=str(object_id), type="model")
        mesh = ET.SubElement(obj, "mesh")

        # Add vertices from combined mesh
        vertices_elem = ET.SubElement(mesh, "vertices")
        for vertex in flap_data["vertices"]:
            ET.SubElement(
                vertices_elem,
                "vertex",
                x=str(vertex[0]),
                y=str(vertex[1]),
                z=str(vertex[2]),
            )

        # Add triangles from combined mesh
        triangles_elem = ET.SubElement(mesh, "triangles")
        for triangle_info in flap_data["triangles"]:
            triangle = ET.SubElement(
                triangles_elem,
                "triangle",
                v1=str(triangle_info["indices"][0]),
                v2=str(triangle_info["indices"][1]),
                v3=str(triangle_info["indices"][2]),
                pid=str(triangle_info["material_id"]),
            )

        flap_data["object_id"] = object_id
        object_id += 1

    # Build section
    build = ET.SubElement(model, "build")  # Add flap objects to build plate
    for flap_data in flaps_data:
        # Since vertices are already transformed to their final positions,
        # use identity transform for the build item
        transform_str = "1 0 0 0 1 0 0 0 1 0 0 0"

        ET.SubElement(
            build,
            "item",
            objectid=str(flap_data["object_id"]),
            transform=transform_str,
        )

    # Create XML tree and return as string
    tree = ET.ElementTree(model)
    ET.indent(tree, space="  ")

    # Convert to string
    xml_str = ET.tostring(model, encoding="unicode")
    return f'<?xml version="1.0" encoding="UTF-8"?>\n{xml_str}'


def create_content_types_xml():
    """Create the [Content_Types].xml file for the 3MF archive."""
    return """<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
  <Default Extension="config" ContentType="application/xml"/>
</Types>"""


def create_rels_xml():
    """Create the _rels/.rels file for the 3MF archive."""
    return """<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" Target="/3D/3dmodel.model" Id="rel0"/>
</Relationships>"""


def arrange_flaps_on_bed(
    num_flaps,
    flap_width=54.0,
    flap_height=43,
    spacing=2.0,
    bed_width=250.0,
    bed_height=200.0,
):
    """
    Calculate positions for flaps on the print bed.

    Args:
        num_flaps: Number of flaps to arrange
        flap_width: Width of each flap in mm
        flap_height: Height of each flap in mm
        spacing: Spacing between flaps in mm
        bed_width: Width of print bed in mm
        bed_height: Height of print bed in mm

    Returns:
        List of (x, y) positions for each flap
    """
    positions = []

    # Calculate how many flaps fit in one row
    flaps_per_row = int(bed_width // (flap_width + spacing))
    if flaps_per_row == 0:
        flaps_per_row = 1

    # Calculate how many rows fit on the bed
    rows_per_bed = int(bed_height // (flap_height + spacing))
    if rows_per_bed == 0:
        rows_per_bed = 1

    for i in range(num_flaps):
        row = i // flaps_per_row
        col = i % flaps_per_row

        x = col * (flap_width + spacing)
        y = row * (flap_height + spacing)

        positions.append((x, y))

    return positions


def calculate_max_flaps_per_bed(
    flap_width=54.0,
    flap_height=43,
    spacing=2.0,
    bed_width=250.0,
    bed_height=200.0,
    wipe_tower_space=1,
    max_flaps_per_bed=99,
):
    """
    Calculate the maximum number of flaps that can fit on one print bed,
    accounting for wipe tower space and user-defined maximum.

    Args:
        flap_width: Width of each flap in mm
        flap_height: Height of each flap in mm
        spacing: Spacing between flaps in mm
        bed_width: Width of print bed in mm
        bed_height: Height of print bed in mm
        wipe_tower_space: Number of flap spaces to reserve for wipe tower
        max_flaps_per_bed: Maximum number of flaps per bed (user limit)

    Returns:
        Maximum number of flaps per bed
    """
    # Calculate how many flaps fit in one row
    flaps_per_row = int(bed_width // (flap_width + spacing))
    if flaps_per_row == 0:
        flaps_per_row = 1

    # Calculate how many rows fit on the bed
    rows_per_bed = int(bed_height // (flap_height + spacing))
    if rows_per_bed == 0:
        rows_per_bed = 1

    # Total flaps that could theoretically fit
    max_flaps = flaps_per_row * rows_per_bed

    # Reserve space for wipe tower (subtract wipe_tower_space flaps)
    max_flaps_with_wipe_tower = max(max_flaps - wipe_tower_space, 1)

    # Apply user-defined maximum limit
    return min(max_flaps_with_wipe_tower, max_flaps_per_bed)


def combine_meshes_for_flap(flap_meshes):
    """
    Combine multiple STL meshes into a single mesh with material assignments.
    Triangles are grouped by material for proper volume ranges.

    Applies the transformation matrix to position vertices correctly on the print bed.

    Args:
        flap_meshes: List of mesh info dicts for a single flap

    Returns:
        Dict with combined vertices, triangles, and material info
    """
    all_vertices = []
    all_triangles = []
    vertex_offset = 0

    # Process meshes in material order to ensure proper triangle grouping
    mesh_data = {}
    for mesh_info in flap_meshes:
        try:
            stl_mesh = trimesh.load(mesh_info["file_path"])
            vertices = stl_mesh.vertices
            faces = stl_mesh.faces
            material_id = mesh_info["extruder"]
            transform = mesh_info["transform"]

            mesh_data[material_id] = {
                "vertices": vertices,
                "faces": faces,
                "transform": transform,
                "mesh_info": mesh_info,
            }

            logging.info(
                f"Loaded {len(vertices)} vertices and {len(faces)} faces from {mesh_info['mesh_id']} (material {material_id})"
            )

        except Exception as e:
            logging.warning(f"Could not load mesh {mesh_info['file_path']}: {e}")
            continue

    # Combine meshes in material order (1, 2, 3) for proper volume ranges
    for material_id in sorted(mesh_data.keys()):
        data = mesh_data[material_id]
        vertices = data["vertices"]
        faces = data["faces"]
        transform = data[
            "transform"
        ]  # Apply transformation matrix to position vertices correctly on print bed
        # Add homogeneous coordinate (w=1) to each vertex for 4x4 transformation
        vertices_homogeneous = np.column_stack([vertices, np.ones(len(vertices))])
        transformed_vertices_homogeneous = vertices_homogeneous.dot(transform.T)
        transformed_vertices = transformed_vertices_homogeneous[:, :3]

        # Add transformed vertices to combined list
        all_vertices.extend(transformed_vertices)

        # Add triangles with material assignment and adjusted vertex indices
        for face in faces:
            triangle_info = {
                "indices": [
                    face[0] + vertex_offset,
                    face[1] + vertex_offset,
                    face[2] + vertex_offset,
                ],
                "material_id": material_id,
            }
            all_triangles.append(triangle_info)

        vertex_offset += len(transformed_vertices)
        logging.info(f"Added {len(faces)} triangles for material {material_id}")

    return {"vertices": all_vertices, "triangles": all_triangles}


def create_slic3r_config(flaps_data):
    """
    Create slic3r_pe_model.config file content for PrusaSlicer multi-material support.

    Args:
        flaps_data: List of flap data with object_id and material info

    Returns:
        Config file content as XML string
    """
    # Create root config element
    config = ET.Element("config")

    for flap_data in flaps_data:
        object_id = flap_data["object_id"]
        flap_idx = flap_data["flap_idx"]

        # Create object element
        obj_elem = ET.SubElement(
            config, "object", id=str(object_id), instances_count="1"
        )

        # Add object metadata
        obj_metadata = ET.SubElement(
            obj_elem,
            "metadata",
            type="object",
            key="name",
            value=f"{flap_idx:02d}_flap",
        )

        # Group triangles by material to create volumes
        volumes_by_material = {}
        for i, triangle_info in enumerate(flap_data["triangles"]):
            material_id = triangle_info["material_id"]
            if material_id not in volumes_by_material:
                volumes_by_material[material_id] = {
                    "triangles": [],
                    "first_id": None,
                    "last_id": None,
                }
            volumes_by_material[material_id]["triangles"].append(i)

        # Calculate ranges for each material (triangles are grouped by material in order)
        current_triangle_id = 0
        for material_id in sorted(volumes_by_material.keys()):
            triangle_count = len(volumes_by_material[material_id]["triangles"])
            volumes_by_material[material_id]["first_id"] = current_triangle_id
            volumes_by_material[material_id]["last_id"] = (
                current_triangle_id + triangle_count - 1
            )
            current_triangle_id += triangle_count

        # Calculate the centroid of the flap body (material 1) for relative positioning
        flap_body_centroid = None
        if 1 in volumes_by_material:
            # Extract vertices for material 1 (flap body) to calculate centroid
            material_1_triangles = volumes_by_material[1]["triangles"]
            if material_1_triangles:
                # Get vertex indices for all triangles of material 1
                vertex_indices = set()
                for tri_idx in material_1_triangles:
                    triangle_info = flap_data["triangles"][tri_idx]
                    vertex_indices.update(triangle_info["indices"])

                # Calculate centroid from these vertices
                vertices_sum = [0.0, 0.0, 0.0]
                for v_idx in vertex_indices:
                    vertex = flap_data["vertices"][v_idx]
                    vertices_sum[0] += vertex[0]
                    vertices_sum[1] += vertex[1]
                    vertices_sum[2] += vertex[2]

                count = len(vertex_indices)
                flap_body_centroid = [
                    vertices_sum[0] / count,
                    vertices_sum[1] / count,
                    vertices_sum[2] / count,
                ]

        # Create volume elements for each material
        for material_id in sorted(volumes_by_material.keys()):
            volume_data = volumes_by_material[material_id]
            first_id = volume_data["first_id"]
            last_id = volume_data["last_id"]

            # Create volume element
            volume_elem = ET.SubElement(
                obj_elem, "volume", firstid=str(first_id), lastid=str(last_id)
            )

            # Determine material name and source file
            material_names = {1: "flap", 2: "letter_front", 3: "letter_back"}
            material_name = material_names.get(material_id, f"material_{material_id}")
            source_file = f"{flap_idx:02d}_{material_name}.stl"

            # Calculate relative transform matrix for this volume
            if material_id == 1:  # Flap body - use identity matrix
                matrix_value = "1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1"
                offset_x, offset_y, offset_z = 27.0, 20.8, 0.0  # Default flap center
            else:  # Letters - calculate relative to flap body
                # Calculate centroid of this material
                material_triangles = volume_data["triangles"]
                vertex_indices = set()
                for tri_idx in material_triangles:
                    triangle_info = flap_data["triangles"][tri_idx]
                    vertex_indices.update(triangle_info["indices"])

                vertices_sum = [0.0, 0.0, 0.0]
                for v_idx in vertex_indices:
                    vertex = flap_data["vertices"][v_idx]
                    vertices_sum[0] += vertex[0]
                    vertices_sum[1] += vertex[1]
                    vertices_sum[2] += vertex[2]

                count = len(vertex_indices)
                material_centroid = [
                    vertices_sum[0] / count,
                    vertices_sum[1] / count,
                    vertices_sum[2] / count,
                ]

                # Calculate relative offset from flap body centroid
                if flap_body_centroid:
                    rel_x = material_centroid[0] - flap_body_centroid[0]
                    rel_y = material_centroid[1] - flap_body_centroid[1]
                    rel_z = material_centroid[2] - flap_body_centroid[2]
                else:
                    rel_x, rel_y, rel_z = 0.0, 0.0, 0.0

                # Create transformation matrix with relative positioning
                matrix_value = f"1 0 0 {rel_x} 0 1 0 {rel_y} 0 0 1 {rel_z} 0 0 0 1"
                offset_x = material_centroid[0]
                offset_y = material_centroid[1]
                offset_z = material_centroid[2]

            # Add volume metadata
            ET.SubElement(
                volume_elem, "metadata", type="volume", key="name", value=source_file
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="volume_type",
                value="ModelPart",
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="matrix",
                value=matrix_value,
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="source_file",
                value=source_file,
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="source_object_id",
                value="0",
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="source_volume_id",
                value="0",
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="source_offset_x",
                value=str(offset_x),
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="source_offset_y",
                value=str(offset_y),
            )
            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="source_offset_z",
                value=str(offset_z),
            )  # Map material IDs to extruder numbers for config file
            # Material 1 (flap body) -> Extruder 1
            # Material 2 (front letters) -> Extruder 2
            # Material 3 (back letters) -> Extruder 2
            extruder_mapping = {1: 1, 2: 2, 3: 2}
            extruder_id = extruder_mapping.get(material_id, material_id)

            ET.SubElement(
                volume_elem,
                "metadata",
                type="volume",
                key="extruder",
                value=str(extruder_id),
            )

            # Add mesh element
            ET.SubElement(
                volume_elem,
                "mesh",
                edges_fixed="0",
                degenerate_facets="0",
                facets_removed="0",
                facets_reversed="0",
                backwards_edges="0",
            )  # Create XML tree and return as string
    tree = ET.ElementTree(config)
    ET.indent(tree, space=" ")
    # Convert to string
    xml_str = ET.tostring(config, encoding="unicode")
    return f'<?xml version="1.0" encoding="UTF-8"?>\n{xml_str}'


def create_slic3r_pe_config():
    """
    Create Slic3r_PE.config file content for PrusaSlicer wipe tower configuration.

    Returns:
        Config file content as string
    """
    return """; wipe_tower_x = 184.93
; wipe_tower_y = 169.242
"""


def write_3mf_file(flaps_data, output_file, meshes_info):
    """
    Write a 3MF file with the given flap data.

    Args:
        flaps_data: List of flap data to include in the file
        output_file: Path to the output 3MF file
        meshes_info: List of all mesh info for statistics
    """
    try:
        with zipfile.ZipFile(output_file, "w", zipfile.ZIP_DEFLATED) as zf:
            # Add required 3MF structure files
            zf.writestr("[Content_Types].xml", create_content_types_xml())
            zf.writestr("_rels/.rels", create_rels_xml())

            # Create and add the model XML
            model_xml = create_3mf_model_xml(flaps_data)
            zf.writestr(
                "3D/3dmodel.model", model_xml
            )  # Create and add the PrusaSlicer config file
            slic3r_config = create_slic3r_config(flaps_data)
            zf.writestr("Metadata/Slic3r_PE_model.config", slic3r_config)

            # Create and add the PrusaSlicer wipe tower config file
            slic3r_pe_config = create_slic3r_pe_config()
            zf.writestr("Metadata/Slic3r_PE.config", slic3r_pe_config)

        logging.info(f"Successfully created 3MF file: {output_file}")
        logging.info(f"The file contains {len(flaps_data)} flaps")

    except Exception as e:
        print(f"Error creating 3MF file: {e}")
        sys.exit(1)


def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(
        description="Create 3MF file for multi-material splitflap printing"
    )
    parser.add_argument(
        "--input",
        "-i",
        type=str,
        default="build/flap_3dp",
        help="Input directory containing flap_XX subdirectories with STL files",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=str,
        default="flaps_printbed",
        help="Output filename (without .3mf extension)",
    )
    parser.add_argument(
        "--count",
        "-c",
        type=int,
        default=52,
        help="Number of flaps to include (default: 52)",
    )
    parser.add_argument(
        "--start",
        "-s",
        type=int,
        default=0,
        help="Starting flap number (default: 0)",
    )
    parser.add_argument(
        "--spacing",
        type=float,
        default=2.0,
        help="Spacing between flaps on print bed in mm (default: 2.0)",
    )
    parser.add_argument(
        "--bed-width",
        type=float,
        default=250.0,
        help="Print bed width in mm (default: 250.0)",
    )
    parser.add_argument(
        "--bed-height",
        type=float,
        default=200.0,
        help="Print bed height in mm (default: 200.0)",
    )
    parser.add_argument(
        "--max-flaps-per-bed",
        type=int,
        default=8,
        help="Maximum number of flaps per bed presuming they all fit on a bed (default: 8)",
    )

    args = parser.parse_args()

    # Convert to absolute paths
    script_dir = Path(__file__).parent
    if not os.path.isabs(args.input):
        input_dir = script_dir.parent / args.input
    else:
        input_dir = Path(args.input)

    # Convert output to base filename (without extension)
    if not os.path.isabs(args.output):
        output_base = input_dir / args.output
    else:
        output_base = Path(args.output)

    # Validate input directory
    if not input_dir.exists():
        print(f"Error: Input directory {input_dir} does not exist")
        sys.exit(1)

    # Calculate maximum flaps per bed (accounting for wipe tower)
    max_flaps_per_bed = calculate_max_flaps_per_bed(
        spacing=args.spacing,
        bed_width=args.bed_width,
        bed_height=args.bed_height,
        max_flaps_per_bed=args.max_flaps_per_bed,
    )

    logging.info(
        f"Maximum flaps per bed: {max_flaps_per_bed} (with space reserved for wipe tower)"
    )

    # Calculate how many output files we'll need
    num_output_files = (args.count + max_flaps_per_bed - 1) // max_flaps_per_bed
    if num_output_files > 1:
        logging.info(
            f"Will create {num_output_files} output files to fit {args.count} flaps"
        )  # Collect flap STL files
    meshes_info = []

    for i in range(args.count):
        flap_idx = args.start + i
        flap_dir = input_dir / f"flap_{flap_idx:02d}"

        if not flap_dir.exists():
            logging.warning(f"Flap directory {flap_dir} does not exist, skipping")
            continue

        # Look for flap body STL
        flap_stl = flap_dir / f"{flap_idx:02d}_flap.stl"
        if flap_stl.exists():
            meshes_info.append(
                {
                    "mesh_id": f"flap_{flap_idx:02d}_body",
                    "file_path": str(flap_stl),
                    "extruder": 1,  # Material 1 - Flap body
                    "flap_idx": flap_idx,
                }
            )
        else:
            logging.warning(f"Flap body STL not found: {flap_stl}")
            continue

        # Look for letter STLs - check for separate front/back first
        front_stl = flap_dir / f"{flap_idx:02d}_letter_front.stl"
        back_stl = flap_dir / f"{flap_idx:02d}_letter_back.stl"
        combined_stl = flap_dir / f"{flap_idx:02d}_letters.stl"
        letter_found = False

        if front_stl.exists():
            meshes_info.append(
                {
                    "mesh_id": f"flap_{flap_idx:02d}_front",
                    "file_path": str(front_stl),
                    "extruder": 2,  # Material 2 - Front letters
                    "flap_idx": flap_idx,
                }
            )
            letter_found = True

        if back_stl.exists():
            meshes_info.append(
                {
                    "mesh_id": f"flap_{flap_idx:02d}_back",
                    "file_path": str(back_stl),
                    "extruder": 3,  # Material 3 - Back letters
                    "flap_idx": flap_idx,
                }
            )
            letter_found = True

        if combined_stl.exists() and not letter_found:
            # Combined letters - assign to front letter extruder
            meshes_info.append(
                {
                    "mesh_id": f"flap_{flap_idx:02d}_letters",
                    "file_path": str(combined_stl),
                    "extruder": 2,  # Material 2 - Letters
                    "flap_idx": flap_idx,
                }
            )
        else:
            if not letter_found:
                logging.warning(f"No letter STLs found for flap {flap_idx:02d}")

    if not meshes_info:
        print("Error: No valid flap STL files found")
        sys.exit(1)

    logging.info(f"Found {len(meshes_info)} mesh components from {args.count} flaps")

    # Group meshes by flap index
    flaps_dict = {}
    for mesh_info in meshes_info:
        flap_idx = mesh_info["flap_idx"]
        if flap_idx not in flaps_dict:
            flaps_dict[flap_idx] = []
        flaps_dict[flap_idx].append(mesh_info)

    # Process flaps in batches based on bed size
    flap_indices = sorted(flaps_dict.keys())

    for batch_idx in range(num_output_files):
        start_idx = batch_idx * max_flaps_per_bed
        end_idx = min(start_idx + max_flaps_per_bed, len(flap_indices))
        batch_flap_indices = flap_indices[start_idx:end_idx]

        if not batch_flap_indices:
            continue

        logging.info(
            f"Processing batch {batch_idx + 1}/{num_output_files} with flaps {batch_flap_indices[0]}-{batch_flap_indices[-1]}"
        )  # Calculate positions for this batch
        flap_width = 54.0  # Width of flap in mm
        flap_height = 43.0  # Height of flap in mm

        batch_flap_positions = arrange_flaps_on_bed(
            len(batch_flap_indices),
            flap_width=flap_width,
            flap_height=flap_height,
            spacing=args.spacing,
            bed_width=args.bed_width,
            bed_height=args.bed_height,
        )

        # Add transforms to meshes for this batch
        batch_flaps_data = []
        for i, flap_idx in enumerate(batch_flap_indices):
            flap_meshes = flaps_dict[flap_idx]
            base_x, base_y = batch_flap_positions[
                i
            ]  # Log whether this flap will be flipped
            if flap_idx % 2 == 1:
                logging.info(
                    f"Flap {flap_idx:02d} will be flipped (front-to-back) and positioned at X={base_x + flap_width:.1f}, Y={base_y:.1f}"
                )
            else:
                logging.info(
                    f"Flap {flap_idx:02d} will be placed normally at X={base_x:.1f}, Y={base_y:.1f}"
                )  # Add transform to each mesh for this flap
            # For odd-numbered flaps, add a 180-degree rotation around Y-axis (flip front-to-back)
            for mesh_info in flap_meshes:
                if flap_idx % 2 == 1:  # Odd-numbered flap
                    # Create rotation around Y axis (180 degrees)
                    rotation = trimesh.transformations.rotation_matrix(np.pi, [0, 1, 0])

                    # Need to adjust position: after Y-axis rotation, we need to offset by flap_width
                    # to maintain proper positioning (flap origin is at bottom left)

                    # Create translation matrix with adjusted x-coordinate
                    # Adding flap_width to correctly position after rotation
                    translation = trimesh.transformations.translation_matrix(
                        [base_x + flap_width, base_y, 0]
                    )

                    # Combine transformations: first rotate, then translate
                    transform = trimesh.transformations.concatenate_matrices(
                        translation, rotation
                    )
                else:  # Even-numbered flap
                    transform = trimesh.transformations.translation_matrix(
                        [base_x, base_y, 0]
                    )
                mesh_info["transform"] = transform

            logging.info(
                f"Processing flap {flap_idx:02d} with {len(flap_meshes)} components"
            )

            # Combine all meshes for this flap
            combined_mesh = combine_meshes_for_flap(flap_meshes)

            flap_data = {
                "flap_idx": flap_idx,
                "vertices": combined_mesh["vertices"],
                "triangles": combined_mesh["triangles"],
                "transform": flap_meshes[0]["transform"],
            }

            batch_flaps_data.append(flap_data)

        # Generate output filename
        if num_output_files == 1:
            output_file = output_base.with_suffix(".3mf")
        else:
            output_file = output_base.with_name(
                f"{output_base.name}_{batch_idx + 1}"
            ).with_suffix(".3mf")

        # Write the 3MF file for this batch
        write_3mf_file(batch_flaps_data, output_file, meshes_info)  # Print summary
    logging.info("Material assignments:")
    logging.info("  Material 1 (Flap Body): Dark color for flap base")
    logging.info("  Material 2 (Front Letters): Light color for front text")
    logging.info("  Material 3 (Back Letters): Light color for back text")
    logging.info("")
    logging.info("Flap orientations:")
    logging.info("  Even-numbered flaps (00, 02, 04...): Normal orientation")
    logging.info(
        "  Odd-numbered flaps (01, 03, 05...): Flipped front-to-back (180Â° around Y-axis)"
    )
    logging.info(
        "  Odd-numbered flaps are positioned with an offset to avoid overlap with even-numbered flaps"
    )


if __name__ == "__main__":
    main()
